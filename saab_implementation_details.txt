SAAB Tech2 Protocol Implementation Details
=======================================

1. Serial Port Configuration
---------------------------
baudRate: 19200
bufferSize: 16384
Other settings:
- No flow control (xonxoff, rtscts, dsrdtr all disabled)
- 8 data bits
- No parity
- 1 stop bit

2. Protocol Commands
------------------
a) Download Mode Command:
[239, 86, 128, 59]  // Hex: EF 56 80 3B
- Used to enter download mode
- Must be sent twice (once to switch, once to verify)
- Requires 2-second delay after first send
- Expects 4-byte response on verification

b) Restart Command:
[139, 86, 0, 31]    // Hex: 8B 56 00 1F
- Used to restart the Tech2
- Expects 4-byte response
- Requires 15-second delay after restart

3. Data Reading Sequence
----------------------
Five sequential read commands with different offsets:

a) Read Command Structure:
[129, 90, 15, 46, offset_high, offset_low, length_high, length_low]
// Base command: 81 5A 0F 2E

b) Specific Read Commands:
1. [129, 90, 15, 46, 0, 0, 166, 66]      // Read 169 bytes at offset 0
2. [129, 90, 15, 46, 0, 166, 166, 156]   // Read 169 bytes at offset 166
3. [129, 90, 15, 46, 1, 76, 166, 245]    // Read 169 bytes at offset 332
4. [129, 90, 15, 46, 1, 242, 166, 79]    // Read 169 bytes at offset 498
5. [129, 90, 15, 46, 2, 152, 50, 28]     // Read 53 bytes at offset 664

4. Timing Parameters
------------------
- Initial mode switch delay: 2000ms
- Connection verification timeout: 8000ms
- Read operation timeout: 15000ms
- Restart wait time: 15000ms

5. Data Structure
---------------
Total data size: 714 bytes
Breakdown:
- 4 chunks of 166 bytes each (664 bytes)
- 1 chunk of 50 bytes
- Each response includes 2-byte header (not included in final data)

6. Original JavaScript Implementation
---------------------------------
async function readInto(reader, buffer) {
    let offset = 0;
    while (offset < buffer.byteLength) {
        const { value, done } = await reader.read(
            new Uint8Array(buffer, offset)
        );
        if (done) {
            break;
        }
        buffer = value.buffer;
        offset += value.byteLength;
    }
    return buffer;
}

// Main sequence implementation
await port.open({ baudRate: 19200, bufferSize: 16384 });

// Enter download mode
await writer.write(new Uint8Array([239, 86, 128, 59]));
await delay(2000);

// Verify connection
await writer.write(new Uint8Array([239, 86, 128, 59]));
let buffer = await Promise.race([readInto(reader, new ArrayBuffer(4)), timeout(8000)]);

// Read data chunks
let dataBuffers = [];
// Read chunk 1
await writer.write(new Uint8Array([129, 90, 15, 46, 0, 0, 166, 66]));
dataBuffers.push(await Promise.race([readInto(reader, new ArrayBuffer(169)), timeout(15000)]));
// Read chunk 2
await writer.write(new Uint8Array([129, 90, 15, 46, 0, 166, 166, 156]));
dataBuffers.push(await Promise.race([readInto(reader, new ArrayBuffer(169)), timeout(15000)]));
// Read chunk 3
await writer.write(new Uint8Array([129, 90, 15, 46, 1, 76, 166, 245]));
dataBuffers.push(await Promise.race([readInto(reader, new ArrayBuffer(169)), timeout(15000)]));
// Read chunk 4
await writer.write(new Uint8Array([129, 90, 15, 46, 1, 242, 166, 79]));
dataBuffers.push(await Promise.race([readInto(reader, new ArrayBuffer(169)), timeout(15000)]));
// Read chunk 5
await writer.write(new Uint8Array([129, 90, 15, 46, 2, 152, 50, 28]));
dataBuffers.push(await Promise.race([readInto(reader, new ArrayBuffer(53)), timeout(15000)]));

// Combine data chunks
var dataBuffer = new Uint8Array(166+166+166+166+50);
dataBuffer.set(new Uint8Array(dataBuffers[0], 2, 166), 0);
dataBuffer.set(new Uint8Array(dataBuffers[1], 2, 166), 166);
dataBuffer.set(new Uint8Array(dataBuffers[2], 2, 166), 332);
dataBuffer.set(new Uint8Array(dataBuffers[3], 2, 166), 498);
dataBuffer.set(new Uint8Array(dataBuffers[4], 2, 50), 664);

// Restart device
await writer.write(new Uint8Array([139, 86, 0, 31]));
buffer = await Promise.race([readInto(reader, new ArrayBuffer(4)), timeout(15000)]);

7. Error Handling
---------------
- Connection timeout: 8 seconds for verification
- Read timeout: 15 seconds for each data chunk
- Restart timeout: 15 seconds
- Buffer overflow protection
- Response validation for each command

8. Notes
-------
- Each data response includes a 2-byte header that should be stripped
- The protocol appears to be stateful, requiring specific command sequences
- The device must be in the correct mode before data can be read
- Total data size is fixed at 714 bytes
- The protocol includes built-in error checking and timeouts
- The implementation supports both synchronous and asynchronous operations 